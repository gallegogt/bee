//! A module for trimming all transaction fields.

use bee_transaction::constants::*;

const DELIMITER_BYTE: u8 = 0xFF;
const OFFSETS: [usize; 15] = [
    EXTRA_DATA_DIGEST.4 - 1,
    ADDRESS.4 - 1,
    VALUE.4 - 1,
    ISSUANCE_TIMESTAMP.4 - 1,
    TIMELOCK_LOWER_BOUND.4 - 1,
    TIMELOCK_UPPER_BOUND.4 - 1,
    BUNDLE_NONCE.4 - 1,
    TRUNK_HASH.4 - 1,
    BRANCH_HASH.4 - 1,
    TAG.4 - 1,
    ATTACHMENT_TIMESTAMP.4 - 1,
    ATTACHMENT_TIMESTAMP_LOWER_BOUND.4 - 1,
    ATTACHMENT_TIMESTAMP_UPPER_BOUND.4 - 1,
    NONCE.4 - 1,
    TRANSACTION_SIZE_BYTES - 1,
];
const LENGTHS: [usize; 15] = [
    SIGNATURE_FRAGMENTS.5,
    EXTRA_DATA_DIGEST.5,
    ADDRESS.5,
    VALUE.5,
    ISSUANCE_TIMESTAMP.5,
    TIMELOCK_LOWER_BOUND.5,
    TIMELOCK_UPPER_BOUND.5,
    BUNDLE_NONCE.5,
    TRUNK_HASH.5,
    BRANCH_HASH.5,
    TAG.5,
    ATTACHMENT_TIMESTAMP.5,
    ATTACHMENT_TIMESTAMP_LOWER_BOUND.5,
    ATTACHMENT_TIMESTAMP_UPPER_BOUND.5,
    NONCE.5,
];

/// Trims all fields of an IOTA transaction.
pub fn trim(bytes: &[u8]) -> Vec<u8> {
    let mut kept_bytes_list = Vec::with_capacity(OFFSETS.len());
    let mut kept_bytes = 0;

    for i in 0..OFFSETS.len() {
        let (last, length) = (OFFSETS[i], LENGTHS[i]);

        let mut is_empty_field = true;

        for i in 0..length {
            if bytes[last - i] != 0 {
                kept_bytes_list.push((last + 1 - length, length - i));
                kept_bytes += length - i + 1; // +1 for the delimiter byte
                is_empty_field = false;
                break;
            }
        }

        if is_empty_field {
            kept_bytes_list.push((last + 1 - length, 0));
            kept_bytes += 1;
        }
    }

    let mut compressed = vec![0; kept_bytes];

    let mut start = 0;
    for (offset, length) in kept_bytes_list {
        compressed[start..start + length]
            .copy_from_slice(&bytes[offset..offset + length]);

        start += length;

        compressed[start] = DELIMITER_BYTE;
        start += 1;
    }

    compressed
}

/// Untrims all fields of an IOTA transaction.
pub fn untrim(bytes: &[u8]) -> Vec<u8> {
    let mut decompressed = vec![0; PACKET_SIZE];

    let mut src = 0;
    let mut dst = 0;
    let mut delta = 0;
    let mut index = 0;

    for i in 0..bytes.len() {
        let is_delimiter = bytes[i] == DELIMITER_BYTE;

        if is_delimiter {
            decompressed[dst..dst + delta].copy_from_slice(&bytes[src..src + delta]);

            index += 1;
            if index >= OFFSETS.len() {
                break;
            }

            dst = OFFSETS[index] + 1 - LENGTHS[index];
            src = i + 1;
            delta = 0;
        } else {
            delta += 1;
        }
    }

    decompressed
}

#[cfg(test)]
mod tests {
    use super::*;
    use bee_protocol::Transaction;

    const TX_TRYTES: &str = "SEGQSWYCJHRLJYEGZLRYQAZPLVRAYIWGWJUMFFX99UZUKBQNFYAOQLOFARIKNEBKDRHJJWDJARXTNPHPAODJRSGJBVVYBVJHZALJWDCJHZRSACOVCVVAVHZVTPFTAJWVGFSVLSYXHNNXEGSMJHDBZKGFQNYJJJBAPDHFFGZ9POSOMWTDPGXI9KQRLMUVWNEQDANMXROVORJVALWVGDDJAFOOBXUKVCCIVXSSHZUCZV9XVBASLWX9NXPWGMGYCRD9ILQMKIGPBGGMKAIJKNALBLABATYFVIRBKTXTWNUZAUXRASB9EEIQHWBD9ZYUDBUPBSWXVYXQXECRCHQAYH9ZBUZBASPOIGBSGWJYFKFRITUBVMCYGCMAPTXOIWEVTUXSUOUPTUQOPMMPUTHXMOP9CW9THAZXEPMOMNEOBLUBPOAIOBEBERRZCIKHSTDWUSUPUWNJOCLNZDCEKWWAAJDPJXJEHHSYFN9MH9BGUDQ9CSZBIHRC9PSQJPGKH9ILZDWUWLEKWFKUFFFIMOQKRMKOYXEJHXLCEGCGGKHGJUHOXINSWCKRNMUNAJDCVLZGEBII9ASTYFTDYDZIZSNHIWHSQ9HODQMVNDKMKHCFDXIIGDIVJSBOOE9GRIXCD9ZUTWCUDKFTETSYSRBQABXCXZFOWQMQFXHYZWD9JZXUWHILMRNWXSGUMIIXZYCTWWHCWMSSTCNSQXQXMQPTM9MOQMIVDYNNARDCVNQEDTBKWOIOSKPKPOZHJGJJGNYWQWUWAZMBZJ9XEJMRVRYFQPJ9NOIIXEGIKMMN9DXYQUILRSCSJDIDN9DCTFGQIYWROZQIEQTKMRVLGGDGA9UVZPNRGSVTZYAPMWFUWDEUULSEEGAGITPJQ9DBEYEN9NVJPUWZTOTJHEQIXAPDOICBNNCJVDNM9YRNXMMPCOYHJDUFNCYTZGRCBZKOLHHUK9VOZWHEYQND9WUHDNGFTAS99MRCAU9QOYVUZKTIBDNAAPNEZBQPIRUFUMAWVTCXSXQQIYQPRFDUXCLJNMEIKVAINVCCZROEWEX9XVRM9IHLHQCKC9VLK9ZZWFBJUZKGJCSOPQPFVVAUDLKFJIJKMLZXFBMXLMWRSNDXRMMDLE9VBPUZB9SVLTMHA9DDDANOKIPY9ULDWAKOUDFEDHZDKMU9VMHUSFG9HRGZAZULEJJTEH9SLQDOMZTLVMBCXVNQPNKXRLBOUCCSBZRJCZIUFTFBKFVLKRBPDKLRLZSMMIQNMOZYFBGQFKUJYIJULGMVNFYJWPKPTSMYUHSUEXIPPPPPJTMDQLFFSFJFEPNUBDEDDBPGAOEJGQTHIWISLRDAABO9H9CSIAXPPJYCRFRCIH9TVBZKTCK9SPQZUYMUOKMZYOMPRHRGF9UAKZTZZG9VVVTIHMSNDREUOUOSLKUHTNFXTNSJVPVWCQXUDIMJIAMBPXUGBNDTBYPKYQYJJCDJSCTTWHOJKORLHGKRJMDCMRHSXHHMQBFJWZWHNUHZLYOAFQTRZFXDBYASYKWEVHKYDTJIAUKNCCEPSW9RITZXBOFKBAQOWHKTALQSCHARLUUGXISDMBVEUKOVXTKTEVKLGYVYHPNYWKNLCVETWIHHVTBWT9UPMTQWBZPRPRSISUBIBECVDNIZQULAGLONGVFLVZPBMHJND9CEVIXSYGFZAGGN9MQYOAKMENSEOGCUNKEJTDLEDCD9LGKYANHMZFSSDDZJKTKUJSFL9GYFDICTPJEPDSBXDQTARJQEWUVWDWSQPKIHPJONKHESSQH9FNQEO9WUCFDWPPPTIQPWCVDYTTWPLCJJVYNKE9ZEJNQBEJBMDBLNJKQDOQOHVS9VY9UPSU9KZVDFOESHNRRWBK9EZCYALAUYFGPCEWJQDXFENSNQEAUWDXJGOMCLQUQWMCPHOBZZ9SZJ9KZXSHDLPHPNYMVUJQSQETTN9SG9SIANJHWUYQXZXAJLYHCZYRGITZYQLAAYDVQVNKCDIYWAYBAFBMAYEAEAGMTJGJRSNHBHCEVIQRXEFVWJWOPU9FPDOWIFL9EWGHICRBNRITJDZNYACOGTUDBZYIYZZWAOCDBQFFNTTSTGKECWTVWZSPHX9HNRUYEAEWXENEIDLVVFMZFVPUNHMQPAIOKVIBDIHQIHFGRJOHHONPLGBSJUD9HHDTQQUZN9NVJYOAUMXMMOCNUFLZ9MXKZAGDGKVADXOVCAXEQYZGOGQKDLKIUPYXIL9PXYBQXGYDEGNXTFURSWQYLJDFKEV9VVBBQLTLHIBTFYBAJSZMDMPQHPWSFVWOJQDPHV9DYSQPIBL9LYZHQKKOVF9TFVTTXQEUWFQSLGLVTGK99VSUEDXIBIWCQHDQQSQLDHZ9999999999999999999TRINITY99999999999999999999TNXSQ9D99A99999999B99999999OGBHPUUHS9CKWSAPIMDIRNSUJ9CFPGKTUFAGQYVMFKOZSVAHIFJXWCFBZLICUWF9GNDZWCOWDUIIZ9999OXNRVXLBKJXEZMVABR9UQBVSTBDFSAJVRRNFEJRL9UFTOFPJHQMQKAJHDBIQAETS9OUVTQ9DSPAOZ9999TRINITY99999999999999999999LPZYMWQME999999999MMMMMMMMMDTIZE9999999999999999999999";

    #[test]
    fn trim_full() {
        let orig = Transaction::from_tryte_str(&TX_TRYTES);
        let bytes = orig.as_bytes();

        let trimmed = trim(&bytes);
        let untrimmed = untrim(&trimmed);

        let clone = Transaction::from_bytes(&untrimmed);
        assert_eq!(orig.as_tryte_string(), clone.as_tryte_string());
    }
}
